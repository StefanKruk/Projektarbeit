\chapter{Problemanalyse}
\label{chap:analyse}
Jedes Internet-Unternehmen fängt klein an und wächst mit der Zeit. In dieser Zeit muss das Unternehmen viele Probleme bewältigen. Es muss die Produkte, welches das Unternehmen verkauft, weiterentwickeln und auf die Bedürfnisse der Nutzer reagieren. In unserer heutigen Zeit, in der das Internet das bevorzugte Informationsmedium ist, können sich Nutzer sehr schnell von einem Produkt zu einem anderen wechseln. Um das zu verhindern, muss ein Produkt immer aktuell sein.

\section{Herkömmliche Produkte}
Herkömmliche Software-Produkte wurden auf CDs/DVDs verkauft und änderten sich daher nie. Um ein aktuelles Produkt zu erhalten, musste die Software in einer aktuellen Version erworben werden und auch diese änderte sich dann nicht. Ggf. wurden Patches zu einem billigeren Preis angeboten, wodurch eine Software geändert und mit neuen Features ausgestattet werden konnte.

Die Informationen welche den Nutzern zur Verfügung standen war außerdem sehr gering, wodurch ein Produktwechsel selten war. Durch die kosten, welche aufgewandt werden mussten, um ein Produkt zu kaufen, war es sehr selten, dass Nutzer sich schnell entschieden ein anderes Produkt zu nutzen.

\section{Derzeitige Produkte}
Wie bereits erwähnt ist das Internet das heute bevorzugte Medium, um Informationen über Produkte und andere Dinge zu erhalten. Nutzer können innerhalb von Minuten Produkte vergleichen und durch Demos diese testen, meistens sogar mit vollem Funktionsumfang. Durch SaaS (Software-as-a-Service) ist auch das wechseln von Produkten nach dem "bezahlen" möglich, da man beim SaaS-Model nur das Zahlt, was man auch wirklich nutzt.

Aus genau diesen Gründen, muss sich ein Internet-Unternehmen sehr schnell anpassen und auf die Bedürfnisse der Nutzer reagieren. Schafft ein Unternehmen dieses nicht, kann es schnell dazuführen, dass es Insolvent wird.

\section{Aktuelles Beispiel: \ebay}
Ein Modernes und aktives Internet-Unternehmen ist \ebay und darf man der Seite \cite{highscalability} glauben, so startet die Seite 1995 als Monolithische Perl Applikation. Selbst wenn diese Informationen nicht auf \ebay zutreffen sollten, so dient es uns doch als gutes Beispiel einer realen Problemstellung.

Laut Wikipedia (https://en.wikipedia.org/wiki/EBay) wurde \ebay 1995 von Pierre Omidyar unter dem Namen \textit{ActionWeb} gegründet und wurde 1997 in \ebay umbenannt. \ebay wurde wie oben schon angesprochen als Monolithische Perl Anwendung implementiert. Mit der Steigerung der Reichweite und der täglichen Benutzung, hatte man sich dann aber dazu entschlossen auf C++ als Code-Basis umzusteigen und die Seite mit CGI zu implementieren. Mittlerweile war \ebay ein großes und sich rasant entwickelndes Unternehmen. Das bedeutet aber auch, dass \ebay ständig auf das Verhalten der Nutzer reagieren und sich anpassen muss. Man versuchte also eine Monolithische Applikation mit der Fähigkeit auszustatten, auf Änderungen schnell zu reagieren, implementieren und deployen. Aber ein Monolith zu deployen, bedeutet, entweder die gesamte Infrastruktur für Wartungszwecke offline zu nehmen und die Applikation neu zu deployen, oder Server im Parallel betrieb laufen zu lassen und jeden neuen Traffic auf die neue Version zu routen. Die letzte Methode bietet jedoch einige Schwierigkeiten, denn es könnten Änderungen eingebaut worden sein, welche im Konflikt mit der alten Version stehen. Dann muss in jedem Fall die erste Variante gewählt werden und die gesamte Infrastruktur offline genommen werden.

Beide Varianten der Änderungen sind jedoch zeitaufwendig und  schwierig, denn nicht nur das deployen könnte Probleme bereiten, sondern auch die darauf folgende Ausführung des Programms. Ändert man Code in Monolithischen Applikationen kann das auch Auswirkungen auf bestehende Teile des Codes haben, welche vorher, ohne Probleme, funktioniert haben. Werden Tests vernachlässigt oder wird nicht ausreichend getestet, kann es leicht passieren, dass sich ungewollt Fehler einschleichen, wodurch dann eine Version in betrieb genommen wird, welche Fehler enthält. Darauf folgend müssten diese wieder behoben werden und die Anwendung erneut deployed werden.

Im Falle einer Monolithischen Architektur bedeutet das viele Änderungen und neue Features. Oft passiert es daher, dass Code Stücke zurückbleiben, welche nicht mehr benötigt werden. Irgendwann ist die Applikation daher so groß, dass sie nicht mehr Wartbar ist und neue Features nur noch schwer zu implementieren sind. Entstehen Fehler in solch einer Anwendung ist es um so schwerer diese zu finden und zu beheben. Schließlich hat sich \ebay entschlossen ihre "Anwendung" in Java neu zu implementieren. Dieses mal jedoch mit dem Hintergrund einer leicht erweiterbaren und wartbaren Architektur.

\section{Das Problem}
Das Problem besteht also darin, "eine Anwendung" flexibel und einfach erweiterbar zu gestalten, damit ein Unternehmen schnell auf Änderungen und die veränderten Bedürfnisse der Nutzer reagieren kann. Damit solch eine Software ebenfalls gut Wartbar ist, sollten Redundanzen möglichst vermieden werden. Hier steigen wir in Modularität ein, denn damit eine Software möglichst einfach Wartbar ist, sollte jeder Code mit einem bestimmten Kontext in ein eigenes Modul gepackt werden. So können zum Beispiel alle Codestücke einer bestimmten Berechnung in ein Modul gepackt werden, wodurch diese dann nur an einer zentralen Stellen geändert werden muss. Wenn die Module jedoch auch von verschiedenen Applikationen genutzt werden, müssen diese in Libraries ausgelagert werden. Auch hier hat man wieder nur eine zentrale Stelle, an der Änderungen vorgenommen werden müssen, um die Berechnung anzupassen oder zu ändern. Jedoch besteht hier das Problem, dass wenn Änderungen durchgeführt werden, diese noch lange nicht in jeder laufenden Applikation zu finden sind. Dazu müssen diese nämlich erst einmal neu gebaut und deployed werden, damit diese Produktiv werden.

Um dieses Vorgehen zu vereinfachen hat man sich dazu entschieden, diese Libraries in eigene Applikationen (Services) zu verpacken und diese über eine Schnittstelle anzubieten. Das sorgt dafür, dass jede Software, welche dieses Modul benötigt, sie nicht mehr eigenständig implementieren muss, sondern den dafür vorgesehenen Service aufrufe kann, um die nötigen Informationen zu erhalten. Diese Services werden auch als Microservices bezeichnet, da sie nur einem bestimmten Zweck dienen, dafür ihre Aufgabe aber besonders gut erledigen. Hierbei kann man unter anderem von einer \SOA\ (SOA) sprechen. Es sollte jedoch darauf geachtet werden, dass weder zu viel, noch zu wenig in ein Service gepackt wird. Welche Größe genau richtig ist, wird im Kapitel \secref{chap:grundlagen} weiter erläutert.